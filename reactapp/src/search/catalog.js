/**
 * Centralized catalog for problems across the site.
 * This file is the single source of truth for all algorithm and problem data.
 */

// --- ✅ Combined Icon Imports for ALL Categories ---
import {
  AlignLeft,
  ArrowLeftRight,
  ArrowRightLeft,
  ArrowUpDown,
  BarChart3,
  BarChart4,
  Calculator,
  Check,
  CheckCircle,
  CheckCircle2,
  Circle,
  Clock,
  Code2,
  Coins,
  Container,
  Crown,
  Database,
  Droplets,
  Edit,
  Filter,
  GitBranch,
  GitMerge,
  Grid,
  Hash,
  Infinity as InfinityIcon,
  Layers,
  LineChart,
  List,
  ListOrdered,
  MapPin,
  Maximize2,
  Merge,
  Minus,
  Mountain,
  MoveRight,
  Plus,
  RefreshCw,
  Repeat,
  RotateCcw,
  Scissors,
  Search,
  SearchCode,
  Settings,
  Share2,
  ShoppingBasket,
  Shuffle,
  Target,
  Text,
  ToggleRight,
  Trees,
  TrendingUp,
  Users,
  Grid3x3,
  Zap,
  PackageOpen,
  UtensilsCrossed,
  Eye,
} from "lucide-react";

export const problems = [
  // =================================================================
  // ARRAYS
  // =================================================================
  {
    label: "Container With Most Water",
    category: "Arrays",
    subpage: "ContainerWithMostWater",
    keywords: ["array", "two pointers", "container", "water", "11"],
    number: "11",
    icon: Container,
    description: "Find two lines that form a container with the most water.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange to-orange",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #11", "GfG"],
    tags: ["Two Pointers", "Area"],
  },
  {
    label: "3Sum",
    category: "Arrays",
    subpage: "ThreeSum",
    keywords: ["array", "two pointers", "three sum", "3sum", "triplet", "15"],
    number: "15",
    icon: Target,
    description: "Find all unique triplets that sum up to zero.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-success to-success500",
    iconColor: "text-success",
    iconBg: "bg-success/20",
    borderColor: "border-emerald-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n²)",
    platforms: ["LeetCode #15", "GfG"],
    tags: ["Two Pointers", "Sorting", "Triplets"],
  },
  {
    label: "4Sum",
    category: "Arrays",
    subpage: "4Sum",
    keywords: [
      "array",
      "four sum",
      "4sum",
      "quadruplets",
      "two pointers",
      "18",
    ],
    number: "18",
    icon: Layers,
    description:
      "Find all unique quadruplets in the array which give the sum of a target.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange to-orange",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n³)",
    platforms: ["LeetCode #18", "GfG"],
    tags: ["Two Pointers", "Sorting", "Quadruplets"],
  },
  {
    label: "Trapping Rain Water",
    category: "Arrays",
    subpage: "TrappingRainWater",
    keywords: ["array", "two pointers", "rain", "water", "42"],
    number: "42",
    icon: Droplets,
    description: "Compute how much water can be trapped after raining.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-danger500 to-pink500",
    iconColor: "text-danger",
    iconBg: "bg-danger-light",
    borderColor: "border-danger/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #42", "GfG"],
    tags: ["Two Pointers", "DP", "Water"],
  },
  {
    label: "Maximum Subarray",
    category: "Arrays",
    subpage: "MaximumSubarray",
    keywords: [
      "array",
      "kadane",
      "maximum subarray",
      "53",
      "subarray sum",
      "dynamic programming",
    ],
    number: "53",
    icon: TrendingUp,
    description: "Find the subarray with the largest sum.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-success500 to-teal-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Kadane's Algorithm",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #53", "GfG"],
    tags: ["DP", "Kadane", "Classic"],
  },
  {
    label: "Merge Intervals",
    category: "Arrays",
    subpage: "MergeIntervals",
    keywords: ["array", "intervals", "merge", "56", "overlapping", "sorting"],
    number: "56",
    icon: Merge,
    description: "Merge all overlapping intervals.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange500 to-danger500",
    iconColor: "text-orange",
    iconBg: "bg-orangelight",
    borderColor: "border-orange/30",
    technique: "Sorting + Greedy",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #56", "GfG"],
    tags: ["Intervals", "Sorting", "Important"],
  },
  {
    label: "Best Time to Buy and Sell Stock",
    category: "Arrays",
    subpage: "BestTimeToBuyAndSellStock",
    keywords: ["array", "stock", "profit", "buy", "sell", "121"],
    number: "121",
    icon: TrendingUp,
    description: "Find the maximum profit from a single buy and sell.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-accent-primary",
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-success500 to-success-hover",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "One Pass",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #121"],
    tags: ["Kadane's variant", "Profit"],
  },
  {
    label: "Maximum Gap",
    category: "Arrays",
    subpage: "MaximumGap",
    keywords: ["array", "maximum", "gap", "sorting", "bucket sort", "164"],
    number: "164",
    icon: MoveRight,
    description: "Find the max gap between successive elements in sorted form.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange to-orange",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Sorting, Traversal",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #164"],
    tags: ["Sorting", "Traversal"],
  },
  {
    label: "Rotate Array",
    category: "Arrays",
    subpage: "RotateArray",
    keywords: ["array", "rotate", "reverse", "in-place", "189"],
    number: "189",
    icon: RotateCcw,
    description: "Rotate the array to the right by k steps.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Reverse Algorithm",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #189", "GfG"],
    tags: ["Array", "In-place", "Rotation"],
  },
  {
    label: "Product of Array Except Self",
    category: "Arrays",
    subpage: "ProductOfArrayExceptSelf",
    keywords: [
      "array",
      "product",
      "prefix",
      "suffix",
      "238",
      "except self",
      "division",
    ],
    number: "238",
    icon: Calculator,
    description: "Find the product of all elements except self.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-purple500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Prefix & Suffix Products",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #238", "GfG"],
    tags: ["Array", "Prefix Sum", "Important"],
  },
  {
    label: "Move Zeros",
    category: "Arrays",
    subpage: "MoveZeros",
    keywords: ["array", "move", "zeros", "two pointers", "in-place", "283"],
    number: "283",
    icon: MoveRight,
    description: "Move all zeros to the end while maintaining order.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-accent-primary",
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-purple500 to-purple500",
    iconColor: "text-purple",
    iconBg: "bg-purple/20",
    borderColor: "border-purple500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #283", "GfG"],
    tags: ["Two Pointers", "Partitioning"],
  },
  {
    label: "Split Array Largest Sum",
    category: "Arrays",
    subpage: "SplitArrayLargestSum",
    keywords: [
      "array",
      "split",
      "largest sum",
      "binary search",
      "greedy",
      "410",
    ],
    number: "410",
    icon: BarChart3,
    description: "Split array so the largest subarray sum is minimized.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-pink-500 to-pink600",
    iconColor: "text-pink",
    iconBg: "bg-pink-light",
    borderColor: "border-pink/30",
    technique: "Binary Search + Greedy",
    timeComplexity: "O(n log(sum))",
    platforms: ["LeetCode #410"],
    tags: ["Binary Search", "Greedy"],
  },
  {
    label: "Squares of a Sorted Array",
    category: "Arrays",
    subpage: "SquaresOfSortedArray",
    keywords: ["array", "squares", "sorted", "two pointers", "977"],
    number: "977",
    icon: ArrowUpDown,
    description: "Square each number and return the sorted array.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-accent-primary",
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #977"],
    tags: ["Two Pointers", "Sorting"],
  },
  {
    label: "Max Consecutive Ones III",
    category: "Arrays",
    subpage: "MaxConsecutiveOnesIII",
    keywords: ["array", "sliding window", "ones", "1004"],
    number: "1004",
    icon: ToggleRight,
    description: "Longest subarray of 1s after flipping at most K zeros.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #1004", "GfG"],
    tags: ["Sliding Window", "Ones"],
  },
  {
    label: "Sum of Subarray Ranges",
    category: "Arrays",
    subpage: "SubarrayRanges",
    keywords: ["array", "ranges", "subarray", "stack", "monotonic", "2104"],
    number: "2104",
    icon: ArrowUpDown,
    description: "Sum of differences between max and min in all subarrays.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-pink-500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Array / Monotonic Stack",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #2104", "GfG"],
    tags: ["Subarrays", "Stack"],
  },
  {
    label: "Find Maximum Element",
    category: "Arrays",
    subpage: "FindMaxElement",
    keywords: ["array", "max", "find", "largest", "basic"],
    number: "1",
    icon: Maximize2,
    description: "Find the largest element in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-emerald-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Traversal"],
  },
  {
    label: "Find Minimum Element",
    category: "Arrays",
    subpage: "FindMinElement",
    keywords: ["array", "min", "find", "smallest", "basic"],
    number: "2",
    icon: Minus,
    description: "Find the smallest element in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success to-teal-500",
    iconColor: "text-success",
    iconBg: "bg-success/20",
    borderColor: "border-emerald-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Traversal"],
  },
  {
    label: "Array Sum",
    category: "Arrays",
    subpage: "ArraySum",
    keywords: ["array", "sum", "total", "basic"],
    number: "3",
    icon: Plus,
    description: "Calculate the sum of all elements in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-accent-primary500 to-cyan-500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Sum"],
  },
  {
    label: "Reverse Array",
    category: "Arrays",
    subpage: "ReverseArray",
    keywords: ["array", "reverse", "two pointers", "in-place", "basic"],
    number: "4",
    icon: RefreshCw,
    description: "Reverse the elements of an array in place.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-purple500 to-accent-primary500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Two Pointers"],
  },
  {
    label: "Two Sum",
    category: "Arrays",
    subpage: "TwoSum",
    keywords: ["array", "two sum", "target", "hashmap", "1"],
    number: "1",
    icon: Target,
    description: "Find two numbers that add up to the target value.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-accent-primary",
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-orange500 to-orange500",
    iconColor: "text-orange",
    iconBg: "bg-orangelight",
    borderColor: "border-orange/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #1", "GfG"],
    tags: ["Hashing", "Pairs"],
  },
  {
    label: "Count Zeros in Array",
    category: "Arrays",
    subpage: "CountZeros",
    keywords: ["array", "count", "zeros", "basic"],
    number: "3",
    icon: Hash,
    description: "Count the number of zero elements in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["GfG"],
    tags: ["Beginner", "Counting"],
  },

  // =================================================================
  // SLIDING WINDOWS
  // =================================================================
  {
    label: "Sliding Window Maximum",
    category: "SlidingWindows",
    subpage: "SlidingWindowMaximum",
    keywords: ["sliding window", "maximum", "deque", "monotonic", "239"],
    number: "239",
    icon: BarChart3,
    description: "Find the maximum value in each sliding window of size k.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-purple500 to-pink-500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Deque / Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Deque", "Hard"],
  },
  {
    label: "Max Consecutive Ones III", // Duplicate but kept for category context
    category: "SlidingWindows",
    subpage: "MaxConsecutiveOnesIII",
    keywords: [
      "sliding window",
      "max",
      "consecutive",
      "ones",
      "flip",
      "1004",
      "array",
    ],
    number: "1004",
    icon: ToggleRight,
    description:
      "Find the longest subarray of 1s after flipping at most K zeros.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Two Pointers", "Variable Window"],
  },
  {
    label: "Fruit Into Baskets",
    category: "SlidingWindows",
    subpage: "FruitIntoBaskets",
    keywords: ["sliding window", "fruit", "baskets", "distinct", "904"],
    number: "904",
    icon: ShoppingBasket,
    description:
      "Find the length of the longest subarray with at most two distinct fruit types.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange500 to-orange500",
    iconColor: "text-orange",
    iconBg: "bg-orangelight",
    borderColor: "border-orange/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Variable Window", "Hash Map"],
  },
  {
    label: "Minimum Window Substring",
    category: "SlidingWindows",
    subpage: "MinimumWindow",
    keywords: [
      "sliding window",
      "minimum",
      "window",
      "substring",
      "string",
      "hash map",
      "76",
    ],
    number: "76",
    icon: Target,
    description:
      "Find the minimum window in string s that contains all characters of string t.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-orange500 to-orange500",
    iconColor: "text-orange",
    iconBg: "bg-orangelight",
    borderColor: "border-orange/30",
    technique: "Sliding Window",
    timeComplexity: "O(n+m)",
    platforms: ["LeetCode #76", "GfG"],
    tags: ["String", "Hash Map", "Minimum Window", "Advanced"],
  },
  {
    label: "Longest Substring Without Repeating Characters",
    category: "SlidingWindows",
    subpage: "LongestSubstring",
    keywords: [
      "sliding window",
      "longest",
      "substring",
      "repeating",
      "unique",
      "string",
      "hash map",
      "3",
    ],
    number: "3",
    icon: Hash,
    description:
      "Find the length of the longest substring without repeating characters.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-success500 to-teal-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #3", "GfG"],
    tags: ["String", "Hash Map", "Unique Characters"],
  },

  // =================================================================
  // BINARY SEARCH (New Category Added and Sorted by Number)
  // =================================================================
  {
    label: "Basic Binary Search",
    category: "BinarySearch",
    subpage: "BinarySearchBasic",
    keywords: ["binary search", "basic", "search", "sorted"],
    number: "N/A",
    icon: SearchCode,
    description:
      "The fundamental logarithmic search algorithm on a sorted array.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-teal-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(log n)",
    platforms: ["All Platforms"],
    tags: ["Fundamental", "Logarithmic"],
  },
  {
    label: "Search a 2D Matrix",
    category: "BinarySearch",
    subpage: "Search2DMatrix",
    keywords: ["binary search", "matrix", "2d", "74"],
    number: "74",
    icon: SearchCode,
    description:
      "Search for a value in an m x n matrix where rows and columns are sorted.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-fuchsia-500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Binary Search on 2D Array",
    timeComplexity: "O(log(m*n))",
    platforms: ["LeetCode #74"],
    tags: ["Matrix", "Logarithmic"],
  },
  {
    label: "Find First and Last Position of Element in Sorted Array",
    category: "BinarySearch",
    subpage: "FindFirstAndLastPosition",
    keywords: ["binary search", "first", "last", "position", "34"],
    number: "34",
    icon: SearchCode,
    description:
      "Find the starting and ending position of a given target value.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange500 to-orange500",
    iconColor: "text-orange",
    iconBg: "bg-orangelight",
    borderColor: "border-orange/30",
    technique: "Modified Binary Search",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #34"],
    tags: ["Boundary Search", "Logarithmic"],
  },
  {
    label: "Search in Rotated Sorted Array",
    category: "BinarySearch",
    subpage: "SearchInRotatedSortedArray",
    keywords: ["binary search", "rotated", "sorted array", "33"],
    number: "33",
    icon: SearchCode,
    description: "Search for a target value in a rotated sorted array.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-danger500 to-pink500",
    iconColor: "text-danger",
    iconBg: "bg-danger-light",
    borderColor: "border-danger/30",
    technique: "Binary Search (Pivot)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #33"],
    tags: ["Pivot", "Logarithmic", "Rotated Array"],
  },
  {
    label: "Find Peak Element",
    category: "BinarySearch",
    subpage: "FindPeakElement",
    keywords: ["binary search", "peak", "element", "162"],
    number: "162",
    icon: Mountain,
    description:
      "Find a peak element in an array (an element greater than its neighbors).",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-success500 to-emerald-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Binary Search (Gradient)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #162"],
    tags: ["Gradient", "Logarithmic"],
  },
  {
    label: "Find Minimum in Rotated Sorted Array",
    category: "BinarySearch",
    subpage: "FindMinimumInRotatedSortedArray",
    keywords: ["binary search", "minimum", "rotated", "sorted array", "153"],
    number: "153",
    icon: RotateCcw,
    description: "Find the minimum element in a rotated sorted array.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-accent-primary500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Binary Search (Pivot)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #153"],
    tags: ["Pivot", "Logarithmic", "Rotated Array"],
  },
  {
    label: "Peak Index in a Mountain Array",
    category: "BinarySearch",
    subpage: "PeakIndexInMountainArray",
    keywords: ["binary search", "mountain", "peak", "852"],
    number: "852",
    icon: Mountain,
    description: "Find the index of the peak element in a mountain array.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "Binary Search",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #852"],
    tags: ["Mountain Array", "Logarithmic"],
  },
  {
    label: "Min Speed to Arrive on Time",
    category: "BinarySearch",
    subpage: "MinSpeedToArriveOnTime",
    keywords: ["binary search", "speed", "time", "optimization", "1870"],
    number: "1870",
    icon: Clock,
    description: "Find the minimum speed to arrive at the destination on time.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-cyan-500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Binary Search on Answer",
    timeComplexity: "O(n log(max_speed))",
    platforms: ["LeetCode #1870"],
    tags: ["Search on Answer", "Optimization"],
  },
  {
    label: "Median of Two Sorted Arrays",
    category: "BinarySearch",
    subpage: "MedianOfTwoSortedArrays",
    keywords: ["binary search", "median", "sorted array", "hard", "4"],
    number: "4",
    icon: Share2,
    description: "Find the median of two sorted arrays of different sizes.",
    difficulty: "Hard",
    tier: "Tier 4",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-fuchsia-500 to-purple500",
    iconColor: "text-fuchsia-400",
    iconBg: "bg-fuchsia-500/20",
    borderColor: "border-fuchsia-500/30",
    technique: "Binary Search on Partition",
    timeComplexity: "O(log(min(m,n)))",
    platforms: ["LeetCode #4"],
    tags: ["Partition", "Hard", "Classic"],
  },

  // =================================================================
  // LINKED LIST
  // =================================================================
  {
    label: "Linked List Cycle",
    category: "LinkedList",
    subpage: "LinkedListCycle",
    keywords: [
      "linked list",
      "cycle",
      "loop",
      "floyd",
      "tortoise",
      "hare",
      "141",
    ],
    number: "141",
    icon: InfinityIcon,
    description: "Determine if a given linked list contains a cycle or a loop.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success to-teal-500",
    iconColor: "text-success",
    iconBg: "bg-success/20",
    borderColor: "border-emerald-500/30",
    technique: "Floyd's Cycle",
    timeComplexity: "O(n)",
    tags: ["Two Pointers", "Classic"],
  },
  {
    label: "Reverse Linked List",
    category: "LinkedList",
    subpage: "ReverseLinkedList",
    keywords: ["linked list", "reverse", "iterative", "recursive", "206"],
    number: "206",
    icon: RefreshCw,
    description: "Reverse a singly linked list and return the reversed list.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-lime-500",
    iconColor: "text-success",
    iconBg: "bg-success/20",
    borderColor: "border-lime-500/30",
    technique: "Iterative & Recursive Reversal",
    timeComplexity: "O(n)",
    tags: ["Pointers", "Fundamental"],
  },
  {
    label: "Merge Two Sorted Lists",
    category: "LinkedList",
    subpage: "MergeTwoSortedLists",
    keywords: [
      "linked list",
      "merge",
      "sorted",
      "two pointers",
      "dummy node",
      "21",
    ],
    number: "21",
    icon: GitMerge,
    description:
      "Merge two sorted linked lists and return as a single sorted list.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-accent-primary500 to-purple500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Two Pointers & Dummy Node",
    timeComplexity: "O(m + n)",
    tags: ["Two Pointers", "Classic"],
  },
  {
    label: "Sort List",
    category: "LinkedList",
    subpage: "SortList",
    keywords: [
      "linked list",
      "merge sort",
      "sort",
      "divide and conquer",
      "148",
    ],
    number: "148",
    icon: ListOrdered,
    description: "Sort a linked list in ascending order using merge sort.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange500 to-warning",
    iconColor: "text-warning",
    iconBg: "bg-warning-light",
    borderColor: "border-warning/30",
    technique: "Merge Sort (Divide & Conquer)",
    timeComplexity: "O(n log n)",
    tags: ["Merge Sort", "Linked List", "Divide and Conquer"],
  },
  {
    label: "Swap Pairs",
    category: "LinkedList",
    subpage: "SwapPairs",
    keywords: ["linked list", "swap pairs", "recursion", "iteration", "24"],
    number: "24",
    icon: ArrowLeftRight,
    description: "Swap every two adjacent nodes in a linked list.",
    difficulty: "Medium",
    tier: "Tier 1",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-accent-primary500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Pointer Manipulation (Recursion / Iteration)",
    timeComplexity: "O(n)",
    tags: ["Linked List", "Recursion", "Swapping"],
  },

  // =================================================================
  // STACK
  // =================================================================
  {
    label: "Stack Operations",
    category: "Stack",
    subpage: "StackOperations",
    keywords: ["stack", "operations", "push", "pop", "peek", "LIFO", "basic"],
    number: "Basic",
    icon: Layers,
    description: "Visualize the core stack operations: Push, Pop, and Peek.",
    difficulty: "Fundamental",
    tier: "Tier 1",
    difficultyColor: "text-teal",
    difficultyBg: "bg-teal/10",
    difficultyBorder: "border-cyan-400/30",
    gradient: "from-success500 to-emerald-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "LIFO",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "LIFO"],
  },
  {
    label: "Permutation",
    category: "Stack",
    subpage: "Permutation",
    keywords: ["stack", "permutation", "iterative", "backtracking", "46"],
    number: "46",
    icon: ArrowUpDown,
    description:
      "Generate all permutations of an array iteratively using an explicit stack.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-success to-success500",
    iconColor: "text-success",
    iconBg: "bg-success/20",
    borderColor: "border-emerald-500/30",
    technique: "Explicit Stack",
    timeComplexity: "O(n × n!)",
    tags: ["Backtracking", "Iterative"],
  },
  {
    label: "Largest Rectangle in Histogram",
    category: "Stack",
    subpage: "LargestRectangleHistogram",
    keywords: ["stack", "largest", "rectangle", "histogram", "monotonic", "84"],
    number: "84",
    icon: BarChart4,
    description: "Given bar heights, find the area of the largest rectangle.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-danger500 to-pink500",
    iconColor: "text-danger",
    iconBg: "bg-danger-light",
    borderColor: "border-danger/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Hard"],
  },
  {
    label: "Remove K Digits",
    category: "Stack",
    subpage: "RemoveKDigits",
    keywords: ["stack", "remove", "k digits", "smallest", "greedy", "402"],
    number: "402",
    icon: Scissors,
    description:
      "Given a number, remove K digits to create the smallest possible new number.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange to-orange",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Greedy + Stack",
    timeComplexity: "O(n)",
    tags: ["Greedy", "Monotonic"],
  },
  {
    label: "Sum of Subarray Ranges", // Also in Arrays
    category: "Stack",
    subpage: "SubarrayRanges",
    keywords: [
      "stack",
      "subarray",
      "ranges",
      "sum",
      "monotonic",
      "2104",
      "array",
    ],
    number: "2104",
    icon: ArrowUpDown,
    description: "Calculate sum of (max - min) over all subarrays.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-purple500",
    iconColor: "text-purple",
    iconBg: "bg-purple/20",
    borderColor: "border-purple500/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Arrays"],
  },
  {
    label: "Next Greater Element",
    category: "Stack",
    subpage: "NextGreaterElement",
    keywords: [
      "stack",
      "next",
      "greater",
      "element",
      "monotonic",
      "circular",
      "496",
    ],
    number: "496",
    icon: ArrowUpDown,
    description:
      "Find the next greater element for each element in a circular array.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-fuchsia-500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Circular Array"],
  },

  // =================================================================
  // QUEUE
  // =================================================================
  {
    label: "Basic Queue (FIFO)",
    category: "Queue",
    subpage: "BasicQueue",
    keywords: [
      "queue",
      "fifo",
      "first-in-first-out",
      "enqueue",
      "dequeue",
      "linear",
    ],
    number: "N/A",
    icon: ArrowRightLeft,
    description:
      "Elements are added at the rear and removed from the front, like a waiting line.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-pink500 to-pink-600",
    iconColor: "text-pink",
    iconBg: "bg-pink/20",
    borderColor: "border-pink500/30",
    technique: "Linear Structure",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "FIFO"],
  },
  {
    label: "Circular Queue",
    category: "Queue",
    subpage: "CircularQueue",
    keywords: ["queue", "circular", "ring buffer", "array optimization"],
    number: "N/A",
    icon: List,
    description: "Optimized queue using a circular array to reuse space.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-pink-500 to-pink600",
    iconColor: "text-pink",
    iconBg: "bg-pink-light",
    borderColor: "border-pink/30",
    technique: "Circular Array",
    timeComplexity: "O(1)",
    tags: ["Optimization", "Array"],
  },
  {
    label: "Implement Queue using Stacks",
    category: "Queue",
    subpage: "QueueUsingStacks",
    keywords: ["queue", "implement", "stacks", "design", "amortized", "232"],
    number: "232",
    icon: Container,
    description: "Implement a FIFO queue using only two LIFO stacks.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-accent-primary500 to-accent-primary600",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Two Stacks",
    timeComplexity: "Amortized O(1)",
    tags: ["Design", "Stack"],
  },

  // =================================================================
  // SORTING
  // =================================================================
  {
    label: "Bubble Sort",
    category: "Sorting",
    subpage: "BubbleSort",
    keywords: ["sorting", "bubble", "swap", "basic"],
    number: "912",
    icon: ArrowUpDown,
    description:
      "A simple algorithm that repeatedly steps through the list, comparing and swapping adjacent elements.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-emerald-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Swapping",
    timeComplexity: "O(n²)",
    tags: ["Basic", "In-place"],
  },
  {
    category: "Sorting",
    subpage: "BucketSort",
    label: "Bucket Sort",
    keywords: [
      "sorting",
      "bucket",
      "linear-time",
      "range-based",
      "concatenate",
    ],
    number: "N/A",
    icon: PackageOpen,
    description:
      "Distribution-based, non-comparative sorting: normalize values into buckets, sort each bucket (e.g., with a stable insertion sort), and concatenate.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-teal-300",
    difficultyBg: "bg-teal/10",
    difficultyBorder: "border-teal/30",
    gradient: "from-teal-600 to-cyan-600",
    iconColor: "text-teal-300",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "Distribution",
    timeComplexity: "O(n + k)",
    tags: [
      "Stable (with insertion)",
      "Not in-place",
      "Range-dependent",
      "Avg linear",
    ],
  },
  {
    label: "Merge Sort",
    category: "Sorting",
    subpage: "MergeSort",
    keywords: ["sorting", "merge", "divide and conquer", "stable"],
    number: "N/A",
    icon: GitMerge,
    description:
      "An efficient, stable algorithm using the divide and conquer paradigm.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-warning500 to-orange500",
    iconColor: "text-warning",
    iconBg: "bg-warning-light",
    borderColor: "border-warning/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "Stable"],
  },
  {
    label: "Quick Sort",
    category: "Sorting",
    subpage: "QuickSort",
    keywords: ["sorting", "quick", "partition", "pivot"],
    number: "N/A",
    icon: Shuffle,
    description:
      "An efficient algorithm that uses partitioning to divide the array into smaller sub-arrays.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange500 to-danger500",
    iconColor: "text-orange",
    iconBg: "bg-orangelight",
    borderColor: "border-orange/30",
    technique: "Partitioning",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "In-place"],
  },
  {
    label: "Insertion Sort",
    category: "Sorting",
    subpage: "InsertionSort",
    keywords: ["sorting", "insertion", "insert", "stable"],
    number: "N/A",
    icon: Code2,
    description:
      "A simple algorithm that builds the final sorted array one element at a time.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-lime-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Insertion",
    timeComplexity: "O(n²)",
    tags: ["Basic", "Stable"],
  },
  {
    label: "Radix Sort",
    category: "Sorting",
    subpage: "RadixSort",
    keywords: ["sorting", "radix", "digit", "non-comparative"],
    number: "N/A",
    icon: Layers,
    description:
      "A non-comparative algorithm that sorts numbers by processing individual digits.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-cyan-500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Digit-wise Sorting",
    timeComplexity: "O(d*(n+k))",
    tags: ["Non-comparative", "Linear Time"],
  },
  {
    label: "Counting Sort",
    category: "Sorting",
    subpage: "CountingSort",
    keywords: ["sorting", "counting", "frequency", "non-comparative"],
    number: "N/A",
    icon: BarChart3,
    description:
      "A non-comparative algorithm that counts the frequency of each element to sort them.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange to-warning",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Counting & Placement",
    timeComplexity: "O(n+k)",
    tags: ["Non-comparative", "Linear Time"],
  },
  {
    label: "Heap Sort",
    category: "Sorting",
    subpage: "HeapSort",
    keywords: ["sorting", "heap", "priority queue", "binary heap"],
    number: "N/A",
    icon: Trees,
    description:
      "A comparison-based technique based on a binary heap data structure.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-accent-primary500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Heap-based Sorting",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "In-place"],
  },
  {
    label: "Selection Sort",
    category: "Sorting",
    subpage: "SelectionSort",
    keywords: ["sorting", "selection", "select", "minimum"],
    number: "N/A",
    icon: Target,
    description:
      "A simple algorithm that repeatedly selects the minimum element and moves it to the sorted part.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-emerald-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Selection",
    timeComplexity: "O(n²)",
    tags: ["Basic", "In-place"],
  },
  {
    label: "Shell Sort",
    category: "Sorting",
    subpage: "ShellSort",
    keywords: ["sorting", "shell", "gap", "insertion sort"],
    number: "N/A",
    icon: Layers,
    description:
      "An optimized version of insertion sort that allows the exchange of items that are far apart.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "Gap Insertion",
    timeComplexity: "O(n^1.5)",
    tags: ["Optimization", "In-place"],
  },
  {
    label: "Comb Sort",
    category: "Sorting",
    subpage: "CombSort",
    keywords: ["sorting", "comb", "gap", "bubble sort"],
    number: "N/A",
    icon: Filter,
    description:
      "An improvement over Bubble Sort, Comb Sort eliminates 'turtles' for better performance.",
    difficulty: "Medium",
    tier: "Tier 1",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-accent-primary500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Gap Insertion",
    timeComplexity: "O(n log n)",
    tags: ["Optimization", "In-place"],
  },
  {
    label: "Pancake Sort",
    category: "Sorting",
    subpage: "PancakeSort",
    keywords: ["sorting", "pancake", "flip", "reversal", "comparative"],
    number: "N/A",
    icon: UtensilsCrossed,
    description:
      "A comparison-based algorithm that repeatedly flips subarrays to bring the largest element to its correct position, similar to flipping pancakes in a stack.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-pink-500 to-pink500",
    iconColor: "text-pink",
    iconBg: "bg-pink/20",
    borderColor: "border-pink500/30",
    technique: "Reversal-based Sorting",
    timeComplexity: "O(n²)",
    tags: ["In-place", "Comparison-based", "Unstable"],
  },

  // HEAPS // =================================================================
  // =================================================================
  {
    category: "Heaps",
    subpage: "Heapify", // <-- This MUST match the 'case' in HeapsPage
    label: "Heapify (Build Heap)",
    number: "H-01", // Custom ID for a concept
    difficulty: "Medium",
    difficultyBg: "bg-warning-light",
    difficultyColor: "text-warning",
    difficultyBorder: "border-warning/30",
    tier: "Tier 1",
    description:
      "Learn how to convert an unordered array into a max-heap in-place using the sift-down (heapify) operation.",
    icon: Layers, // This is already imported
    gradient: "from-teal-700 to-cyan-800",
    borderColor: "border-teal-600",
    iconBg: "bg-teal-light",
    iconColor: "text-teal-300",
    tags: ["Heap", "In-Place", "Data Structure", "Concept"],
    technique: "Sift-Down",
    timeComplexity: "O(n)",
    platforms: ["Concept"],
  },
  {
    category: "Heaps",
    subpage: "TopKFrequent", // <-- This MUST match the 'case' in HeapsPage
    label: "Top K Frequent Elements",
    number: "347",
    difficulty: "Medium",
    difficultyBg: "bg-warning-light",
    difficultyColor: "text-warning",
    difficultyBorder: "border-warning/30",
    tier: "Tier 2",
    description:
      "Given an integer array and an integer k, return the k most frequent elements. A min-heap is a perfect solution.",
    icon: TrendingUp, // This is already imported
    gradient: "from-purple700 to-accent-primary800",
    borderColor: "border-purple600",
    iconBg: "bg-purple700/20",
    iconColor: "text-purple",
    tags: ["Heap", "Priority Queue", "Hash Map"],
    technique: "Min-Heap",
    timeComplexity: "O(n log k)",
    platforms: ["LeetCode #347"],
  },
  {
    category: "Heaps",
    subpage: "TaskScheduler", // <-- Este será o nome do nosso novo arquivo/componente
    label: "Task Scheduler",
    number: "621",
    difficulty: "Medium",
    difficultyBg: "bg-warning-light",
    difficultyColor: "text-warning",
    difficultyBorder: "border-warning/30",
    tier: "Tier 2",
    description:
      'Determine o número mínimo de intervalos para completar todas as tarefas com um "cooldown" (folga).',
    icon: Clock, // Ícone perfeito para agendamento
    gradient: "from-accent-primary700 to-accent-primary800", // Um novo gradiente
    borderColor: "border-accent-primary600",
    iconBg: "bg-accent-primary700/20",
    iconColor: "text-accent-primary",
    tags: ["Heap", "Greedy", "Priority Queue", "Scheduling"],
    technique: "Max-Heap / Greedy",
    timeComplexity: "O(N)", // O(N) para contar, o resto é O(1) pois o alfabeto é fixo (26)
    platforms: ["LeetCode #621"],
    keywords: [
      "heap",
      "task",
      "scheduler",
      "cooldown",
      "greedy",
      "priority queue",
      "621",
    ],
  },

  // =================================================================
  // TREES
  // =================================================================
  {
    label: "Construct Tree from Traversal",
    category: "Trees",
    subpage: "ConstructBinaryTree",
    keywords: [
      "tree",
      "construct",
      "build",
      "preorder",
      "inorder",
      "traversal",
      "105",
    ],
    number: "105",
    icon: GitMerge,
    description:
      "Build a binary tree from its preorder and inorder traversal arrays.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-success to-success500",
    iconColor: "text-success",
    iconBg: "bg-success/20",
    borderColor: "border-emerald-500/30",
    technique: "Recursion & Hashing",
    timeComplexity: "O(n)",
    tags: ["Recursion", "Hash Map"],
  },
  {
    label: "LCA of Deepest Leaves",
    category: "Trees",
    subpage: "LCAofDeepestLeaves",
    keywords: [
      "tree",
      "lca",
      "lowest common ancestor",
      "deepest leaves",
      "dfs",
      "1123",
    ],
    number: "1123",
    icon: GitMerge,
    description:
      "Find the lowest common ancestor node of a binary tree's deepest leaves.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Depth-First Search (DFS)",
    timeComplexity: "O(n)",
    tags: ["DFS", "Recursion"],
  },
  {
    label: "Validate Binary Search Tree",
    category: "Trees",
    subpage: "ValidateBST",
    keywords: ["tree", "validate", "bst", "binary search tree", "dfs", "98"],
    number: "98",
    icon: CheckCircle,
    description:
      "Determine if a given binary tree is a valid Binary Search Tree (BST).",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "DFS & Boundaries",
    timeComplexity: "O(n)",
    tags: ["DFS", "Validation"],
  },
  {
    label: "AVL Tree Visualizer",
    category: "Trees",
    subpage: "AVLTree",
    keywords: [
      "tree",
      "avl",
      "balanced",
      "binary search tree",
      "rotations",
      "110",
    ],
    number: "110",
    icon: GitMerge,
    description: "Visualize AVL tree insertions and self-balancing rotations.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-pink-500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Balanced Binary Search Tree",
    timeComplexity: "O(log n)",
    tags: ["Self-Balancing", "BST"],
  },
  {
    label: "Symmetric Tree",
    category: "Trees",
    subpage: "SymmetricTreeVisualizer",
    keywords: [
      "tree",
      "symmetric",
      "mirror",
      "binary tree",
      "recursion",
      "iterative",
      "101",
    ],
    number: "111",
    icon: GitBranch,
    description:
      "Check whether a binary tree is symmetric (a mirror of itself) using recursion or iterative BFS/DFS approaches.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success400 to-emerald-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Tree Traversal (Recursion / BFS)",
    timeComplexity: "O(n)",
    tags: ["Recursion", "Mirror", "BFS", "DFS"],
  },

  // =================================================================
  // DESIGN
  // =================================================================
  {
    label: "LRU Cache",
    category: "Design",
    subpage: "LRUCache",
    keywords: [
      "design",
      "lru",
      "cache",
      "least recently used",
      "hashmap",
      "doubly linked list",
      "146",
    ],
    number: "146",
    icon: Settings,
    description:
      "Implement an LRU (Least Recently Used) cache with O(1) get and put operations.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-teal-500 to-emerald-500",
    iconColor: "text-teal",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "HashMap + Doubly Linked List",
    timeComplexity: "O(1)",
    tags: ["Cache", "Classic"],
  },
  {
    label: "LFU Cache",
    category: "Design",
    subpage: "LFUCache",
    keywords: [
      "design",
      "lfu",
      "cache",
      "least frequently used",
      "hashmap",
      "460",
    ],
    number: "460",
    icon: Settings,
    description:
      "Implement an LFU (Least Frequently Used) cache that evicts the least frequently used key.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-pink-500 to-pink500",
    iconColor: "text-pink",
    iconBg: "bg-pink-light",
    borderColor: "border-pink/30",
    technique: "HashMap + Frequency Map",
    timeComplexity: "O(1)",
    tags: ["Cache", "Hard"],
  },
  {
    label: "Design HashMap",
    category: "Design",
    subpage: "DesignHashMap",
    keywords: ["design", "hashmap", "hashtable", "hash function", "706"],
    number: "706",
    icon: Settings,
    description:
      "Design a HashMap that supports put, get, and remove operations in O(1) time.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-lime-500",
    iconColor: "text-success",
    iconBg: "bg-success/20",
    borderColor: "border-lime-500/30",
    technique: "Array + Hashing",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "Data Structure"],
  },
  {
    label: "Design Linked List",
    category: "Design",
    subpage: "DesignLinkedList",
    keywords: ["design", "linked list", "pointers", "707"],
    number: "707",
    icon: Settings,
    description:
      "Design a Linked List that supports insert, delete, and get operations.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-warning500 to-orange500",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Pointers",
    timeComplexity: "O(n)",
    tags: ["Fundamental", "Data Structure"],
  },
  {
    label: "Min Stack",
    category: "Design",
    subpage: "MinStack",
    keywords: ["design", "min stack", "stack", "minimum", "155"],
    number: "155",
    icon: Layers,
    description:
      "Design a stack that supports retrieving the minimum element in constant time.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-accent-primary500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Stack + Min Tracking",
    timeComplexity: "O(1)",
    tags: ["Stack", "Optimization"],
  },
  {
    label: "Implement Trie (Prefix Tree)",
    category: "Design",
    subpage: "ImplementTrie",
    keywords: ["design", "trie", "prefix tree", "strings", "208"],
    number: "208",
    icon: Search,
    description:
      "Implement a trie with insert, search, and startsWith methods.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-success500 to-teal-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Trie / Tree",
    timeComplexity: "O(m)",
    tags: ["Tree", "Strings"],
  },

  // =================================================================
  // PATHFINDING
  // =================================================================
  {
    label: "A* Pathfinding",
    category: "Pathfinding",
    subpage: "AStar",
    keywords: [
      "pathfinding",
      "a star",
      "a*",
      "heuristic",
      "optimal path",
      "astar",
      "shortest path",
      "grid search",
    ],
    number: "N/A",
    icon: Target,
    description:
      "Optimal pathfinding algorithm using heuristic functions. Guarantees shortest path with efficient exploration.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-danger500 to-pink-500",
    iconColor: "text-danger",
    iconBg: "bg-danger-light",
    borderColor: "border-danger/30",
    technique: "Heuristic Search",
    timeComplexity: "O(b^d)",
    platforms: ["All Platforms"],
    tags: ["Heuristic", "Optimal Path"],
  },
  {
    label: "Rat in a Maze",
    category: "Pathfinding",
    subpage: "RatInMaze",
    keywords: [
      "pathfinding",
      "maze",
      "rat",
      "backtracking",
      "bfs",
      "dfs",
      "graph traversal",
    ],
    number: "N/A",
    icon: MapPin,
    description:
      "Find a path for a rat to reach from a source to a destination in a maze.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-pink-500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Backtracking / BFS / DFS",
    timeComplexity: "O(N*M)",
    tags: ["Backtracking", "Matrix"],
  },
  {
    label: "Flood Fill",
    category: "Pathfinding",
    subpage: "FloodFill",
    keywords: [
      "pathfinding",
      "flood fill",
      "bucket tool",
      "bfs",
      "dfs",
      "graph traversal",
      "matrix",
      "733",
    ],
    number: "733",
    icon: Zap,
    description:
      "Fill an area with a color starting from a seed point. Implemented using BFS.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-cyan-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "BFS / DFS",
    timeComplexity: "O(N*M)",
    platforms: ["LeetCode #733"],
    tags: ["Matrix", "Traversal"],
  },
  {
    label: "Color Islands",
    category: "Pathfinding",
    subpage: "ColorIslands",
    keywords: [
      "pathfinding",
      "color islands",
      "flood fill",
      "number of islands",
      "200",
    ],
    number: "200",
    icon: Grid,
    description: "Identify and color each island (connected 1s) in a 2D grid.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-accent-primary500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Flood Fill (BFS / DFS)",
    timeComplexity: "O(N*M)",
    platforms: ["LeetCode #200"],
    tags: ["Matrix", "Traversal", "Islands"],
  },

  // =================================================================
  // RECURSION
  // =================================================================
  {
    label: "Subset Sum",
    category: "Recursion",
    subpage: "SubsetSumVisualizer",
    keywords: [
      "recursion",
      "subset",
      "sum",
      "backtracking",
      "dynamic programming",
    ],
    number: "25",
    icon: GitMerge,
    description: "Check if a subset of an array sums up to a given value.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange to-orange",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Backtracking",
    timeComplexity: "O(2^n)",
    tags: ["Backtracking", "DP"],
  },
  {
    label: "Tower of Hanoi",
    category: "Recursion",
    subpage: "TowerOfHanoiVisualizer",
    keywords: ["recursion", "tower", "hanoi", "puzzle", "divide and conquer"],
    number: "26",
    icon: Container,
    description:
      "Move a stack of disks from one rod to another following specific rules.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-pink-500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(2^n)",
    tags: ["Classic Puzzle", "Divide & Conquer"],
  },
  {
    label: "Fibonacci",
    category: "Recursion",
    subpage: "FibonacciVisualizer",
    keywords: ["recursion", "fibonacci", "memoization", "dynamic programming"],
    number: "27",
    icon: Zap,
    description:
      "Visualize the recursive call tree for the Fibonacci sequence.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Tree Recursion",
    timeComplexity: "O(2^n)",
    tags: ["Fundamental", "Tree Recursion"],
  },
  {
    label: "Factorial",
    category: "Recursion",
    subpage: "FactorialVisualizer",
    keywords: ["recursion", "factorial", "linear recursion", "call stack"],
    number: "28",
    icon: Hash,
    description:
      "Calculate factorial using recursion and visualize the linear call stack.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-accent-primary500 to-accent-primary500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Linear Recursion",
    timeComplexity: "O(n)",
    tags: ["Fundamental", "Call Stack"],
  },
  {
    label: "N-Queens",
    category: "Recursion",
    subpage: "NQueensVisualizer",
    keywords: ["recursion", "n-queens", "backtracking", "chessboard", "puzzle"],
    number: "29",
    icon: Crown,
    description:
      "Place N queens on an N×N chessboard so that no two queens attack each other.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-pink-500 to-pink500",
    iconColor: "text-pink",
    iconBg: "bg-pink-light",
    borderColor: "border-pink/30",
    technique: "Backtracking",
    timeComplexity: "O(n!)",
    tags: ["Backtracking", "Classic Puzzle"],
  },
  {
    label: "Binary Search (Recursive)",
    category: "Recursion",
    subpage: "BinarySearchRecursiveVisualizer",
    keywords: [
      "recursion",
      "binary search",
      "divide and conquer",
      "sorted array",
    ],
    number: "30",
    icon: Search,
    description: "Search a sorted array using recursive binary search.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-teal-500 to-emerald-500",
    iconColor: "text-teal",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(log n)",
    tags: ["Divide & Conquer", "Logarithmic"],
  },

  // =================================================================
  // STRINGS
  // =================================================================
  {
    label: "Check Palindrome",
    category: "Strings",
    subpage: "PalindromeCheck",
    keywords: ["string", "palindrome", "two pointers", "reverse", "basic"],
    number: "1",
    icon: ArrowLeftRight,
    description: "Check if a string reads the same backward as forward.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-success500 to-emerald-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Two Pointers"],
  },
  {
    label: "Reverse String",
    category: "Strings",
    subpage: "ReverseString",
    keywords: ["string", "reverse", "in-place", "two pointers", "344"],
    number: "344",
    icon: RefreshCw,
    description: "Reverse the characters in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-accent-primary500 to-cyan-500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #344"],
    tags: ["Beginner", "In-place"],
  },
  {
    label: "Count Vowels",
    category: "Strings",
    subpage: "CountVowels",
    keywords: ["string", "count", "vowels", "basic", "traversal"],
    number: "3",
    icon: Hash,
    description: "Count the number of vowels in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-purple500 to-accent-primary500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["GfG"],
    tags: ["Beginner", "Counting"],
  },
  {
    label: "First Unique Character",
    category: "Strings",
    subpage: "FirstUniqueChar",
    keywords: ["string", "first", "unique", "character", "hash map", "387"],
    number: "387",
    icon: CheckCircle2,
    description: "Find the first non-repeating character in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-orange500 to-orange500",
    iconColor: "text-orange",
    iconBg: "bg-orangelight",
    borderColor: "border-orange/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #387"],
    tags: ["Beginner", "Hash Map"],
  },
  {
    label: "Valid Anagram", // Also in Hashing
    category: "Strings",
    subpage: "ValidAnagram",
    keywords: ["string", "anagram", "hashing", "frequency", "242"],
    number: "242",
    icon: Repeat,
    description: "Check if two strings are anagrams of each other.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-accent-primary",
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #242", "GfG"],
    tags: ["Hashing", "Frequency"],
  },
  {
    label: "Longest Common Prefix",
    category: "Strings",
    subpage: "LongestCommonPrefix",
    keywords: ["string", "longest", "common", "prefix", "14"],
    number: "14",
    icon: AlignLeft,
    description: "Find the longest common prefix among an array of strings.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-accent-primary",
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-purple500 to-purple500",
    iconColor: "text-purple",
    iconBg: "bg-purple/20",
    borderColor: "border-purple500/30",
    technique: "String Matching",
    timeComplexity: "O(n*m)",
    platforms: ["LeetCode #14", "GfG"],
    tags: ["Prefix", "Comparison"],
  },
  {
    label: "String Compression",
    category: "Strings",
    subpage: "StringCompression",
    keywords: ["string", "compression", "two pointers", "in-place", "443"],
    number: "443",
    icon: Scissors,
    description: "Compress string using character counts.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-accent-primary",
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-pink-500 to-pink500",
    iconColor: "text-pink",
    iconBg: "bg-pink-light",
    borderColor: "border-pink/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #443"],
    tags: ["Compression", "In-place"],
  },
  {
    label: "Reverse Words",
    category: "Strings",
    subpage: "ReverseWords",
    keywords: ["string", "reverse", "words", "parsing", "151"],
    number: "151",
    icon: Text,
    description: "Reverse the order of words in a string.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-accent-primary",
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "String Manipulation",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #151", "GfG"],
    tags: ["Words", "Parsing"],
  },
  {
    label: "Longest Palindromic Substring",
    category: "Strings",
    subpage: "LongestPalindrome",
    keywords: [
      "string",
      "longest",
      "palindromic",
      "substring",
      "expand around center",
      "5",
    ],
    number: "5",
    icon: ArrowLeftRight,
    description: "Find the longest palindromic substring in a string.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-fuchsia-500 to-purple500",
    iconColor: "text-fuchsia-400",
    iconBg: "bg-fuchsia-500/20",
    borderColor: "border-fuchsia-500/30",
    technique: "Expand Around Center",
    timeComplexity: "O(n²)",
    platforms: ["LeetCode #5", "GfG"],
    tags: ["Palindrome", "DP"],
  },
  {
    label: "Group Anagrams",
    category: "Strings",
    subpage: "GroupAnagrams",
    keywords: ["string", "group", "anagrams", "hashing", "49"],
    number: "49",
    icon: Repeat,
    description: "Group strings that are anagrams of each other.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange to-orange",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Hashing",
    timeComplexity: "O(n*k)",
    platforms: ["LeetCode #49", "GfG"],
    tags: ["Grouping", "Hash Map"],
  },
  {
    label: "Is Subsequence",
    category: "Strings",
    subpage: "IsSubSequence", // <-- Combinando com seu arquivo
    keywords: ["string", "subsequence", "two pointers", "leetcode", "392"],
    number: "392",
    icon: Check, // <-- Vamos usar o ícone "Check"
    description: "Check if one string is a subsequence of another.",
    difficulty: "Easy", // <-- LeetCode diz que é Easy
    tier: "Tier 2", // <-- "Easy" parece ser Tier 2 nesse projeto
    difficultyColor: "text-accent-primary", // Padrão "Easy"
    difficultyBg: "bg-accent-primary/10",
    difficultyBorder: "border-accent-primary/30",
    gradient: "from-accent-primary500 to-cyan-500", // Um novo gradiente
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)", // Onde n é o tamanho da string 't'
    platforms: ["LeetCode #392"],
    tags: ["Two Pointers", "Beginner"],
  },

  // =================================================================
  // HASHING
  // =================================================================
  {
    label: "Valid Anagram", // Also in Strings
    category: "Hashing",
    subpage: "ValidAnagram",
    keywords: [
      "hashing",
      "anagram",
      "valid",
      "character counting",
      "242",
      "string",
    ],
    number: "242",
    icon: Search,
    description: "Check if two strings are anagrams using character counting.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-success",
    difficultyBg: "bg-success/10",
    difficultyBorder: "border-success/30",
    gradient: "from-pink-500 to-purple500",
    iconColor: "text-pink",
    iconBg: "bg-pink-light",
    borderColor: "border-pink/30",
    technique: "Hash Map",
    timeComplexity: "O(n)",
    tags: ["Frequency", "Strings"],
  },
  {
    label: "Subarray Sum Equals K",
    category: "Hashing",
    subpage: "SubarraySumEqualsK",
    keywords: ["hashing", "subarray", "sum", "equals k", "prefix sum", "560"],
    number: "560",
    icon: Database,
    description:
      "Count subarrays whose elements sum to k using prefix sums and hashing.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange to-orange",
    iconColor: "text-orange",
    iconBg: "bg-orange/20",
    borderColor: "border-orange500/30",
    technique: "Prefix Sum + Hash Map",
    timeComplexity: "O(n)",
    tags: ["Prefix Sum", "Arrays"],
  },
  {
    label: "Longest Consecutive Sequence",
    category: "Hashing",
    subpage: "LongestConsecutiveSequence",
    keywords: [
      "hashing",
      "longest",
      "consecutive",
      "sequence",
      "hash set",
      "128",
    ],
    number: "128",
    icon: Hash,
    description:
      "Find the longest sequence of consecutive numbers using a set.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Hash Set Search",
    timeComplexity: "O(n)",
    tags: ["Set", "Arrays"],
  },
  {
    label: "Equal Rows and Columns",
    category: "Hashing",
    subpage: "EqualRowsColumnPairs",
    keywords: [
      "hashing",
      "equal",
      "rows",
      "columns",
      "pairs",
      "grid",
      "matrix",
      "2352",
    ],
    number: "2352",
    icon: Grid3x3,
    description:
      "Count pairs where a row and column contain identical sequences.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-pink-500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Hash Map Frequency",
    timeComplexity: "O(n³)",
    tags: ["Hash Map", "Matrix", "Arrays"],
  },

  // =================================================================
  // GREEDY ALGORITHMS
  // =================================================================
  {
    label: "Best Time to Buy and Sell Stock II",
    category: "GreedyAlgorithms",
    subpage: "BestTimeStockII",
    keywords: ["greedy", "stocks", "buy", "sell", "profit", "122"],
    number: "122",
    icon: TrendingUp,
    description:
      "Maximize profit by buying and selling stocks multiple times with a greedy approach.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-success500 to-emerald-500",
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Greedy Profit",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #122"],
    tags: ["Stocks", "Profit Maximization"],
  },
  {
    label: "Two City Scheduling",
    category: "GreedyAlgorithms",
    subpage: "TwoCityScheduling",
    keywords: [
      "greedy",
      "two city",
      "scheduling",
      "cost",
      "optimization",
      "1029",
    ],
    number: "1029",
    icon: Users,
    description:
      "Schedule interviews for two cities, minimizing the total cost using greedy selection.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-cyan-500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Cost Difference",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #1029"],
    tags: ["Scheduling", "Optimization"],
  },
  {
    label: "Jump Game II",
    category: "GreedyAlgorithms",
    subpage: "JumpGameII",
    keywords: ["greedy", "jump game", "bfs", "array", "45"],
    number: "45",
    icon: Target,
    description:
      "Find the minimum number of jumps to reach the end of an array using a greedy BFS approach.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-orange500 to-orange500",
    iconColor: "text-orange",
    iconBg: "bg-orangelight",
    borderColor: "border-orange/30",
    technique: "Greedy BFS",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #45"],
    tags: ["Array Jumping", "BFS"],
  },
  {
    label: "Gas Station",
    category: "GreedyAlgorithms",
    subpage: "GasStation",
    keywords: ["greedy", "gas station", "circular", "route", "circuit", "134"],
    number: "134",
    icon: Circle,
    description:
      "Find the starting gas station to complete a circular route using a greedy check.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-purple500 to-accent-primary500",
    iconColor: "text-purple",
    iconBg: "bg-purplelight",
    borderColor: "border-purple/30",
    technique: "Circuit Check",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #134"],
    tags: ["Circular Route", "Optimization"],
  },
  {
    label: "Job Scheduling",
    category: "GreedyAlgorithms",
    subpage: "JobScheduling",
    keywords: ["greedy", "dp", "scheduling", "profit", "1235"],
    number: "1235",
    icon: Clock, // Using Clock icon
    description:
      "Maximize profit by scheduling jobs with deadlines and profits.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-danger500 to-orange600",
    iconColor: "text-danger",
    iconBg: "bg-danger-light",
    borderColor: "border-danger/30",
    technique: "Greedy + DP / Binary Search",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #1235"],
    tags: ["Scheduling", "DP", "Hard"],
  },

  // =================================================================
  // DYNAMIC PROGRAMMING
  // =================================================================
  {
    label: "0/1 Knapsack",
    category: "Dynamic Programming",
    subpage: "KnapSack",
    keywords: [
      "dp",
      "dynamic programming",
      "knapsack",
      "0/1",
      "partition",
      "subset sum",
      "416",
    ],
    number: "416",
    icon: TrendingUp,
    description:
      "Determine the maximum value that can be put in a knapsack of capacity W.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-warning to-orange",
    iconColor: "text-warning",
    iconBg: "bg-warning-light",
    borderColor: "border-warning/30",
    technique: "Dynamic Programming",
    timeComplexity: "O(N × W)",
    tags: ["Classic DP", "Optimization"],
  },
  {
    label: "Longest Common Subsequence",
    category: "Dynamic Programming",
    subpage: "LongestCommonSubsequence",
    keywords: ["dp", "lcs", "string", "subsequence", "1143"],
    number: "1143",
    icon: Repeat,
    description:
      "Find the length of the longest subsequence common to two strings.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-accent-primary500 to-accent-primary500",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-light",
    borderColor: "border-accent-primary/30",
    technique: "Dynamic Programming (2D Table)",
    timeComplexity: "O(m × n)",
    platforms: ["LeetCode #1143", "GfG"],
    tags: ["DP", "String", "Subsequence"],
  },
  {
    label: "Coin Change",
    category: "Dynamic Programming",
    subpage: "CoinChange",
    keywords: ["dp", "coin change", "minimum coins", "322"],
    number: "322",
    icon: Coins,
    description:
      "Find the minimum number of coins needed to make a given amount.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-warning500 to-orange500",
    iconColor: "text-warning",
    iconBg: "bg-warning-light",
    borderColor: "border-warning/30",
    technique: "Dynamic Programming (Bottom-Up)",
    timeComplexity: "O(amount × n)",
    platforms: ["LeetCode #322", "GfG"],
    tags: ["DP", "Coin Change", "Optimization"],
  },
  {
    label: "Edit Distance",
    category: "Dynamic Programming",
    subpage: "EditDistance",
    keywords: ["dp", "edit distance", "string", "72"],
    number: "72",
    icon: Edit,
    description:
      "Find the minimum number of operations to convert one string into another.",
    difficulty: "Hard",
    tier: "Tier 4",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-pink500 to-danger500",
    iconColor: "text-danger",
    iconBg: "bg-pink/20",
    borderColor: "border-pink500/30",
    technique: "Dynamic Programming (2D Table)",
    timeComplexity: "O(m × n)",
    platforms: ["LeetCode #72", "GfG"],
    tags: ["DP", "String", "Edit Distance"],
  },
  {
    label: "Longest Increasing Subsequence",
    category: "Dynamic Programming",
    subpage: "LISubsequence",
    keywords: ["dp", "lis", "array", "300"],
    number: "300",
    icon: TrendingUp,
    description:
      "Find the length of the longest increasing subsequence in an array.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-cyan-500 to-accent-primary500",
    iconColor: "text-teal",
    iconBg: "bg-teal/20",
    borderColor: "border-cyan-500/30",
    technique: "Dynamic Programming (Binary Search Optimization)",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #300", "GfG"],
    tags: ["DP", "Subsequence", "Binary Search"],
  },
  {
    label: "Burst Balloons",
    category: "Dynamic Programming",
    subpage: "BurstBalloons", // This MUST match the case in DynamicProgramming.jsx
    keywords: [
      "dp",
      "dynamic programming",
      "burst",
      "balloons",
      "312",
      "interval dp",
      "matrix chain multiplication",
    ],
    number: "312",
    icon: Zap, // Using Zap for the "burst" theme
    description:
      "Find the maximum coins you can collect by bursting balloons in an optimal order using interval DP.",
    difficulty: "Hard",
    tier: "Tier 1", // Tiers are subjective, adjust as needed
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-danger500 to-orange600", // Fiery gradient for "burst"
    iconColor: "text-danger",
    iconBg: "bg-danger-light",
    borderColor: "border-danger/30",
    technique: "Interval DP",
    timeComplexity: "O(n³)",
    tags: ["Interval DP", "Optimization"],
  },
  {
    label: "Buy/Sell Stock IV",
    category: "Dynamic Programming",
    subpage: "SellStockIV", // This MUST match the case in DynamicProgramming.jsx
    keywords: [
      "dp",
      "dynamic programming",
      "stock",
      "buy",
      "sell",
      "transaction",
      "k",
      "188",
    ],
    number: "188",
    icon: LineChart, // Icon for stock charts
    description:
      "Find the maximum profit from at most 'k' transactions using space-optimized DP.",
    difficulty: "Hard",
    tier: "Tier 2",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-success600 to-accent-primary700", // Green/Blue for stocks
    iconColor: "text-success",
    iconBg: "bg-success-light",
    borderColor: "border-success/30",
    technique: "Dynamic Programming",
    timeComplexity: "O(N × K)",
    tags: ["Classic DP", "Optimization", "Space-Optimized"],
  },
  {
    label: "Unique Paths",
    category: "Dynamic Programming",
    subpage: "UniquePaths", // MUST match your navigate() case
    keywords: [
      "dp",
      "dynamic programming",
      "grid",
      "paths",
      "robot",
      "unique",
      "62",
    ],
    number: "62",
    icon: Grid3x3,
    description:
      "Count the number of unique paths in an m×n grid from the top-left corner to the bottom-right using dynamic programming.",
    difficulty: "Medium",
    tier: "Tier 1",
    difficultyColor: "text-warning",
    difficultyBg: "bg-warning/10",
    difficultyBorder: "border-warning/30",
    gradient: "from-teal-600 to-accent-primary700",
    iconColor: "text-teal",
    iconBg: "bg-teal-light",
    borderColor: "border-teal/30",
    technique: "Tabulation",
    timeComplexity: "O(m×n)",
    platforms: ["LeetCode #62"],
    tags: ["Grid DP", "Combinatorics", "Classic Problem"],
  },
  // Graphs
  {
    label: "Max Flow (Edmonds–Karp, Dinic)",
    category: "Graphs",
    subpage: "NetworkFlow",
    keywords: [
      "graphs",
      "graph",
      "max flow",
      "network flow",
      "flow",
      "edmonds-karp",
      "edmonds karp",
      "dinic",
      "ford-fulkerson",
      "residual",
      "bottleneck",
    ],
    number: "N/A",
    icon: GitMerge,
    description:
      "Visualize max flow with Edmonds–Karp (BFS) and Dinic (level graph): residual capacities, augmenting paths, bottlenecks.",
    difficulty: "Hard",
    tier: "Tier 2",
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-accent-primary600 to-accent-primary700",
    iconColor: "text-accent-primary",
    iconBg: "bg-accent-primary-hover/20",
    borderColor: "border-accent-primary600/30",
    technique: "Edmonds–Karp, Dinic",
    timeComplexity: "EK: O(V·E²), Dinic: O(V²·E)",
    tags: ["Residual Graph", "Augmenting Path", "Blocking Flow"],
  },
  {
  label: "Binary Tree Right Side View",
  category: "Trees",
  subpage: "BinaryTreeRightSideView",
  keywords: [
    "binary tree",
    "tree",
    "right side view",
    "bfs",
    "dfs",
    "level order"
  ],
  number: "199",
  icon: Eye, // Assuming 'Eye' is a variable or component reference
  description: "Return the values of the nodes you can see ordered from top to bottom when standing on the right side of a binary tree.",
  difficulty: "Medium",
  tier: "Tier 2",
  difficultyColor: "text-warning",
  difficultyBg: "bg-warning/10",
  difficultyBorder: "border-warning/30",
  gradient: "from-purple500 to-pink-500",
  iconColor: "text-purple",
  iconBg: "bg-purplelight",
  borderColor: "border-purple/30",
  technique: "BFS (Level Order Traversal)",
  timeComplexity: "O(n)",
  platforms: [
    "LeetCode",
    "All Platforms"
  ],
  tags: [
    "Tree",
    "BFS",
    "DFS",
    "Level Order"
  ]
},
{
    label: "Burst Balloons Top Down",
    category: "Dynamic Programming",
    subpage: "BurstBalloonsTopDown", // This MUST match the case in DynamicProgramming.jsx
    keywords: [
      "dp",
      "dynamic programming",
      "burst",
      "balloons",
      "312",
      "interval dp",
      "matrix chain multiplication",
    ],
    number: "312",
    icon: Zap, // Using Zap for the "burst" theme
    description:
      "Find the maximum coins you can collect by bursting balloons in an optimal order using interval DP.",
    difficulty: "Hard",
    tier: "Tier 1", // Tiers are subjective, adjust as needed
    difficultyColor: "text-danger",
    difficultyBg: "bg-danger/10",
    difficultyBorder: "border-danger/30",
    gradient: "from-danger500 to-orange600", // Fiery gradient for "burst"
    iconColor: "text-danger",
    iconBg: "bg-danger-light",
    borderColor: "border-danger/30",
    technique: "Interval DP",
    timeComplexity: "O(n³)",
    tags: ["Interval DP", "Optimization"],
  },
  {
  label: "Print Binary Tree",
  category: "Trees",
  subpage: "PrintBinaryTree", // This MUST match the case in your routing/components
  keywords: [
    "tree",
    "binary tree",
    "print",
    "matrix",
    "layout",
    "recursion",
    "dfs",
    "655",
  ],
  number: "655",
  icon: GitBranch, // Using GitBranch as it represents a tree structure
  description:
    "Construct a 2D string matrix representing the layout of a binary tree.",
  difficulty: "Medium",
  tier: "Tier 3", // Tiers are subjective, adjust as needed
  difficultyColor: "text-warning",
  difficultyBg: "bg-warning/10",
  difficultyBorder: "border-warning/30",
  gradient: "from-accent-primary500 to-success600", // Cool gradient for trees
  iconColor: "text-accent-primary",
  iconBg: "bg-accent-primary-light",
  borderColor: "border-accent-primary/30",
  technique: "Recursion (DFS)",
  timeComplexity: "O(h * 2ʰ)",
  tags: ["Binary Tree", "Recursion", "DFS"],
},
{
  label: "Morris Traversal (Inorder)",
  category: "Trees",
  subpage: "MorrisTraversal", // This MUST match the case in your routing/components
  keywords: [
    "tree",
    "binary tree",
    "inorder",
    "traversal",
    "morris",
    "threaded",
    "94",
    "o(1) space",
  ],
  number: "94",
  icon: GitBranch, // Using GitBranch as it represents the "threading"
  description:
    "Perform an O(1) space inorder traversal using a threaded binary tree approach.",
  difficulty: "Medium",
  tier: "Tier 2", // Tiers are subjective, adjust as needed
  difficultyColor: "text-warning",
  difficultyBg: "bg-warning/10",
  difficultyBorder: "border-warning/30",
  gradient: "from-orange500 to-orange600", // Match visualizer theme
  iconColor: "text-orange",
  iconBg: "bg-orangelight",
  borderColor: "border-orange/30",
  technique: "Morris Traversal",
  timeComplexity: "O(n)",
  tags: ["Binary Tree", "Traversal", "O(1) Space"],
},
{
  label: "Flatten Binary Tree to Linked List",
  category: "Trees",
  subpage: "FlattenBinaryTree", // This MUST match the case in your routing/components
  keywords: [
    "tree",
    "binary tree",
    "flatten",
    "linked list",
    "preorder",
    "dfs",
    "recursion",
    "114",
    "in-place",
    "post-order",
  ],
  number: "114",
  icon: GitBranch, // Using GitBranch as it represents tree structure transformation
  description:
    "Transform a binary tree into a flattened linked list using right pointers in pre-order traversal order.",
  difficulty: "Medium",
  tier: "Tier 2",
  difficultyColor: "text-warning",
  difficultyBg: "bg-warning/10",
  difficultyBorder: "border-warning/30",
  gradient: "from-accent-primary500 to-purple600", // Match visualizer theme
  iconColor: "text-accent-primary",
  iconBg: "bg-accent-primary-light",
  borderColor: "border-accent-primary/30",
  technique: "Post-order DFS",
  timeComplexity: "O(n)",
  tags: ["Binary Tree", "DFS", "Linked List", "Recursion", "In-place"],
},
];
